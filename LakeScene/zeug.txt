shader_type spatial;

uniform float scale_uv : hint_range(0.25,10.0,0.25) = 1.0;
uniform float scale_height : hint_range(0.0,5.0,0.1) = 0.2;
uniform float wave_speed : hint_range(0.0,1.0,0.01) = 0.05;
uniform vec3 color_water : source_color = vec3(0.0, 0.2, 0.6);
uniform vec3 color_depth : source_color = vec3(0.0, 0.05, 0.1);
uniform sampler2D noise : hint_default_black;
uniform sampler2D noise_normalmap : hint_normal;

float wave(vec2 pos) {
	return (2.0 * texture(noise, pos * 1.0).r - 1.0) * scale_height;
}

float height(vec2 pos, float time) {
	vec2 offset = vec2(0.2, 0.3) * time * wave_speed; // <--- Hier ist der fehlende offset
	pos += offset;

	float h = wave(pos + vec2(0.1)) * 0.55; 
	h += wave(pos * 1.5) * 0.3;
	h += wave(pos * 2.5) * 0.1;
	return h;
}

void vertex() {
	vec2 pos = VERTEX.xz * scale_uv;
	float d = 0.05;

	float h = height(pos, TIME);
	float l = height(pos - vec2(d, 0.0), TIME);
	float r = height(pos + vec2(d, 0.0), TIME);
	float t = height(pos - vec2(0.0, d), TIME);
	float b = height(pos + vec2(0.0, d), TIME);

	VERTEX.y += h;

	NORMAL = normalize(vec3((r - l) / (2.0 * d), 1.0, (b - t) / (2.0 * d)));
}

void fragment() {
	ALBEDO = color_water;
	SPECULAR = 1.0;
	ROUGHNESS = 0.1;
}