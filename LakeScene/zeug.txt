shader_type spatial;

uniform float scale_uv : hint_range(0.1, 10.0) = 2.0;
uniform float scale_height : hint_range(0.0, 2.0) = 0.3;
uniform float wave_speed : hint_range(0.0, 2.0) = 0.5;
uniform vec3 color_water : source_color = vec3(0.0, 0.3, 0.6);
uniform vec3 color_depth : source_color = vec3(0.0, 0.05, 0.1);
uniform sampler2D noise : hint_default_black;
uniform sampler2D noise_normalmap : hint_normal;

// Fraktale Noise-Wellenfunktion
float wave(vec2 pos, float scale, float weight) {
    vec2 uv = pos * scale + vec2(TIME * wave_speed, TIME * wave_speed * 0.5);
    return (texture(noise, uv).r * 2.0 - 1.0) * weight;
}

float get_height(vec2 pos) {
    float h = 0.0;
    h += wave(pos, 0.5 * scale_uv, 0.5);
    h += wave(pos, 1.0 * scale_uv, 0.3);
    h += wave(pos, 2.5 * scale_uv, 0.15);
    h += wave(pos, 5.0 * scale_uv, 0.05);
    return h * scale_height;
}

void vertex() {
    vec2 pos = VERTEX.xz;
    float h = get_height(pos);
    VERTEX.y += h;

    // Dynamische Normalenberechnung
    float d = 0.05;
    float hL = get_height(pos - vec2(d, 0.0));
    float hR = get_height(pos + vec2(d, 0.0));
    float hT = get_height(pos - vec2(0.0, d));
    float hB = get_height(pos + vec2(0.0, d));

    NORMAL = normalize(vec3((hR - hL) / (2.0 * d), 1.0, (hB - hT) / (2.0 * d)));
}

void fragment() {
    // Tiefenfarbe nach Normal.y (simulierte Tiefe)
    float depth_factor = clamp(NORMAL.y, 0.0, 1.0);
    vec3 water_color = mix(color_depth, color_water, depth_factor);

    ALBEDO = water_color;
    SPECULAR = 1.0;
    ROUGHNESS = 0.05;
}